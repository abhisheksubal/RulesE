# Rule Engine Unity Integration Example

This example demonstrates how to integrate the Rule Engine with a Unity game to track player progress and award rewards based on game events.

## Overview

The example shows how to track game pieces collected by the player and award different rewards when the player reaches specific milestones (such as collecting 10, 50, or 100 blue pieces).

## Key Components

1. **GameProgressTracker**: Manages the integration between the game and the rule engine.
2. **GameState**: Stores the current state of the game.
3. **RewardHandler**: Processes rewards generated by the rule engine.
4. **AnalyticsManager**: Hooks into the existing analytics tracking system.
5. **Rule Definitions**: JSON file that defines the rules for processing events and milestones.

## How to Use

### Setup

1. Add the `AnalyticsManager` and `GameProgressTracker` components to a persistent GameObject in your scene.
2. Add the `AllRules.json` file to your project as a TextAsset.
3. Assign the rules TextAsset to the `rulesFile` field of the `GameProgressTracker` component.

### Integration with Existing Analytics

The example hooks into your existing analytics tracking method:

```csharp
public void MakeTrackCallWithName(string name, Dictionary<string, object> arguments, string category)
```

The `AnalyticsManager` class provides this method and adds an event that the `GameProgressTracker` listens to.

### Tracking Events

To track a game event:

```csharp
// Using the analytics manager directly
AnalyticsManager.Instance.TrackBluePieceCollected();

// Or using the existing tracking method
Dictionary<string, object> args = new Dictionary<string, object>
{
    { "item_type", "blue_piece" },
    { "count", 1 }
};
AnalyticsManager.Instance.MakeTrackCallWithName("collect_item", args, "gameplay");
```

### Fully Rule-Based Event Processing

The system uses a fully rule-based approach for event processing. When an event occurs:

1. The event data is stored in the game state with each argument accessible as `Event_[argument_name]`
2. Rules are evaluated against this state
3. Rules with matching conditions perform actions (like incrementing counters)

Example rule for processing blue piece collection:

```json
{
  "ruleId": "collect-blue-piece",
  "ruleName": "Blue Piece Collection",
  "type": "simple",
  "conditions": {
    "LastEventName": {
      "operator": "==",
      "value": "collect_item"
    },
    "Event_item_type": {
      "operator": "==",
      "value": "blue_piece"
    }
  },
  "actions": {
    "BluePiecesCollected": {
      "operator": "+=",
      "value": "Event_count"
    },
    "LastCollectedItemType": {
      "operator": "=",
      "value": "Event_item_type"
    }
  }
}
```

### Default Value Handling

Rules can also provide default values for missing arguments:

```json
{
  "ruleId": "default-count-handler",
  "ruleName": "Default Count Handler",
  "type": "simple",
  "conditions": {
    "LastEventName": {
      "operator": "==",
      "value": "collect_item"
    },
    "Event_count": {
      "operator": "==",
      "value": null
    }
  },
  "actions": {
    "Event_count": {
      "operator": "=",
      "value": 1
    }
  }
}
```

### Rule Definitions

Rules are defined in a single JSON file as an array of rule objects. Each rule has:
- Conditions to evaluate
- Actions to perform when conditions are met

The rules file includes:
1. Event processing rules (like the blue piece collection rule)
2. Default value handling rules
3. Milestone rules that check for achievements and award rewards

### Handling Rewards

The `RewardHandler` processes rewards generated by the rule engine. You can subscribe to the `OnRewardProcessed` event to handle rewards in your game:

```csharp
rewardHandler.OnRewardProcessed += (RewardData reward) => {
    // Handle the reward in your game
    Debug.Log($"Player earned reward: {reward.Name}");
};
```

## Extending the Example

### Adding New Item Types

1. Add a new rule to the `AllRules.json` file that handles the collection of the new item type:

```json
{
  "ruleId": "collect-green-piece",
  "ruleName": "Green Piece Collection",
  "type": "simple",
  "conditions": {
    "LastEventName": {
      "operator": "==",
      "value": "collect_item"
    },
    "Event_item_type": {
      "operator": "==",
      "value": "green_piece"
    }
  },
  "actions": {
    "GreenPiecesCollected": {
      "operator": "+=",
      "value": "Event_count"
    }
  }
}
```

2. Add milestone rules for the new item type if needed

### Tracking Other Events

1. Add new event tracking methods to the `AnalyticsManager`
2. Add rules to process the new event types
3. No code changes are needed in the `GameProgressTracker` since it handles all events generically

### Creating Complex Rules

You can create more complex rules by combining conditions:

```json
{
  "ruleId": "special-achievement",
  "ruleName": "Special Achievement",
  "type": "simple",
  "conditions": {
    "BluePiecesCollected": {
      "operator": ">=",
      "value": 50
    },
    "RedPiecesCollected": {
      "operator": ">=",
      "value": 20
    },
    "SpecialAchievementUnlocked": {
      "operator": "==",
      "value": false
    }
  },
  "actions": {
    "Reward": {
      "operator": "=",
      "value": {
        "Type": "Character",
        "CharacterId": "master-collector",
        "Name": "Master Collector Achievement"
      }
    },
    "SpecialAchievementUnlocked": {
      "operator": "=",
      "value": true
    }
  }
}
```

## Benefits of Fully Rule-Based Event Processing

1. **Zero Code Changes for New Events**: Add new event types without changing any code
2. **Complete Configuration Control**: Game designers can modify all aspects of event processing
3. **Dynamic Default Values**: Handle missing arguments with rules rather than code
4. **Complex Event Chains**: Create chains of rules where one rule's actions trigger another rule
5. **Simplified Code**: The code only needs to store event data and process rules

## Best Practices

1. **Consistent Event Naming**: Use a consistent naming convention for events and arguments
2. **Rule Ordering**: Consider rule evaluation order for default value handlers
3. **State Management**: Keep track of what's in your game state to avoid conflicts
4. **Persistence**: Save and load the game state to persist progress between game sessions
5. **Error Handling**: Add proper error handling for rule parsing and execution
6. **Documentation**: Document the available events and their arguments for rule creators

## Example Usage

See the `ExampleUsage.cs` script for a complete example of how to use this system in a Unity game. 